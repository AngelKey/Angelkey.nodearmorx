// Generated by IcedCoffeeScript 108.0.9
(function() {
  var BigInteger, Encoding, a, b58, b62, b64, nbi, nbv, s, _ref;

  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;

  exports.Encoding = Encoding = (function() {
    function Encoding(alphabet, in_block_len) {
      var a, i, _i, _len, _ref1;
      this.alphabet = alphabet;
      this.in_block_len = in_block_len;
      this.base = this.alphabet.length;
      this.base_big = nbv(this.base);
      this.log_base = Math.log2(this.base);
      this.out_block_len = Math.ceil(8 * this.in_block_len / this.log_base);
      this.decode_map = {};
      _ref1 = new Buffer(this.alphabet, 'utf8');
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        a = _ref1[i];
        this.decode_map[a] = i;
      }
    }

    Encoding.prototype.encode = function(src) {
      var i, inc, _;
      inc = this.in_block_len;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for ((inc > 0 ? (i = _i = 0, _len = src.length) : i = _i = src.length - 1); inc > 0 ? _i < _len : _i >= 0; i = _i += inc) {
          _ = src[i];
          _results.push(this.encode_block(src.slice(i, i + inc)));
        }
        return _results;
      }).call(this)).join('');
    };

    Encoding.prototype.encode_block = function(block) {
      var chars, encoded_len, i, num, pad, r, ret;
      encoded_len = this.encoded_len(block.length);
      pad = new Buffer((function() {
        var _i, _ref1, _results;
        _results = [];
        for (_i = 0, _ref1 = this.in_block_len - block.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; 0 <= _ref1 ? _i++ : _i--) {
          _results.push(0);
        }
        return _results;
      }).call(this));
      console.log(pad);
      num = nbi().fromBuffer(Buffer.concat([block, pad]));
      console.log(num);
      chars = (function() {
        var _i, _ref1, _ref2, _results;
        _results = [];
        for (i = _i = 0, _ref1 = this.out_block_len; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _ref2 = num.divideAndRemainder(this.base_big), num = _ref2[0], r = _ref2[1];
          _results.push(this.alphabet[r.intValue()]);
        }
        return _results;
      }).call(this);
      ret = (chars.reverse().slice(0, encoded_len)).join('');
      console.log(ret);
      return ret;
    };

    Encoding.prototype.encoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.in_block_len) {
        return this.out_block_len;
      } else {
        nblocks = ~~(n / this.in_block_len);
        out = nblocks * this.out_block_len;
        if ((rem = n % this.in_block_len) > 0) {
          out += Math.ceil(rem * 8 / this.log_base);
        }
        return out;
      }
    };

    Encoding.prototype.decode = function(src) {
      var bufs, dst;
      src = new Buffer(src, 'utf8');
      bufs = (function() {
        var _ref1, _results;
        _results = [];
        while (src.length) {
          _ref1 = this.decode_block(src), dst = _ref1[0], src = _ref1[1];
          _results.push(dst);
        }
        return _results;
      }).call(this);
      return Buffer.concat(bufs);
    };

    Encoding.prototype.decode_block = function(src) {
      var c, consumed, d, i, pad, padded_len, padlen, res, ret, src_p, _i, _j, _len, _ref1;
      res = nbv(0);
      consumed = 0;
      for (src_p = _i = 0, _len = src.length; _i < _len; src_p = ++_i) {
        c = src[src_p];
        if (!((d = this.decode_map[c]) != null)) {
          continue;
        }
        res = res.multiply(this.base_big).add(nbv(d));
        if (++consumed === this.out_block_len) {
          break;
        }
      }
      for (_j = consumed, _ref1 = this.out_block_len; consumed <= _ref1 ? _j < _ref1 : _j > _ref1; consumed <= _ref1 ? _j++ : _j--) {
        res = res.multiply(this.base_big);
      }
      padded_len = this.decoded_len(consumed);
      ret = consumed === 0 ? new Buffer([]) : (res = (new Buffer(res.toByteArray())).slice(0, padded_len), padlen = padded_len - res.length, pad = new Buffer((function() {
        var _k, _results;
        _results = [];
        for (i = _k = 0; _k < padlen; i = _k += 1) {
          _results.push(0);
        }
        return _results;
      })()), console.log(pad), Buffer.concat([pad, res]));
      return [ret, src.slice(src_p + 1)];
    };

    Encoding.prototype.decoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.out_block_len) {
        return this.in_block_len;
      } else {
        nblocks = ~~(n / this.out_block_len);
        out = nblocks * this.in_block_len;
        if ((rem = n % this.out_block_len) > 0) {
          out += Math.floor(rem * this.log_base / 8);
        }
        return out;
      }
    };

    return Encoding;

  })();

  b58 = {
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
    in_block_len: 19
  };

  b58.encoding = new Encoding(b58.alphabet, b58.in_block_len);

  exports.b58 = b58;

  b62 = {
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    in_block_len: 32
  };

  b62.encoding = new Encoding(b62.alphabet, b62.in_block_len);

  exports.b62 = b62;

  b64 = {
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    in_block_len: 3
  };

  b64.encoding = new Encoding(b64.alphabet, b64.in_block_len);

  exports.b64 = b64;

  s = new Buffer([1, 2]);

  a = b64.encoding.encode(s);

  console.log(a);

  console.log(s.toString('base64'));

  console.log(b64.encoding.decode(a));

}).call(this);
