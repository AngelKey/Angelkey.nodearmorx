// Generated by IcedCoffeeScript 108.0.9
(function() {
  var BigInteger, Encoding, nbi, nbv, std_alphabet, std_encoding, _ref;

  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;

  exports.Encoding = Encoding = (function() {
    function Encoding(alphabet, in_block_len) {
      var a, i, _i, _len, _ref1;
      this.alphabet = alphabet;
      this.in_block_len = in_block_len;
      this.base = 58;
      this.base_big = nbv(this.base);
      this.log58 = Math.log2(this.base);
      this.out_block_len = Math.ceil(8 * this.in_block_len / this.log58);
      if (this.alphabet.length !== this.base) {
        throw new Error("Encoder alphabet length must be 58 chars");
      }
      this.decode_map = {};
      _ref1 = new Buffer(this.alphabet, 'utf8');
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        a = _ref1[i];
        this.decode_map[a] = i;
      }
    }

    Encoding.prototype.encode = function(src) {
      var i, inc, _;
      inc = this.in_block_len;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for ((inc > 0 ? (i = _i = 0, _len = src.length) : i = _i = src.length - 1); inc > 0 ? _i < _len : _i >= 0; i = _i += inc) {
          _ = src[i];
          _results.push(this.encode_block(src.slice(i, i + inc)));
        }
        return _results;
      }).call(this)).join('');
    };

    Encoding.prototype.encode_block = function(block) {
      var chars, i, num, pad, padlen, r;
      num = nbi().fromBuffer(block);
      chars = (function() {
        var _ref1, _results;
        _results = [];
        while (num.compareTo(BigInteger.ZERO) > 0) {
          _ref1 = num.divideAndRemainder(this.base_big), num = _ref1[0], r = _ref1[1];
          _results.push(this.alphabet[r.intValue()]);
        }
        return _results;
      }).call(this);
      chars.reverse();
      padlen = this.encoded_len(block.length) - chars.length;
      pad = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= padlen ? _i < padlen : _i > padlen; i = 0 <= padlen ? ++_i : --_i) {
          _results.push(this.alphabet[0]);
        }
        return _results;
      }).call(this);
      return (pad.concat(chars)).join('');
    };

    Encoding.prototype.encoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.in_block_len) {
        return this.out_block_len;
      } else {
        nblocks = ~~(n / this.in_block_len);
        out = nblocks * this.out_block_len;
        if ((rem = n % this.in_block_len) > 0) {
          out += Math.ceil(rem * 8 / this.log58);
        }
        return out;
      }
    };

    Encoding.prototype.decode = function(src) {
      var bufs, dst;
      src = new Buffer(src, 'utf8');
      bufs = (function() {
        var _ref1, _results;
        _results = [];
        while (src.length) {
          _ref1 = this.decode_block(src), dst = _ref1[0], src = _ref1[1];
          _results.push(dst);
        }
        return _results;
      }).call(this);
      return Buffer.concat(bufs);
    };

    Encoding.prototype.decode_block = function(src) {
      var c, consumed, d, i, pad, padlen, res, src_p, _i, _len;
      res = nbv(0);
      consumed = 0;
      for (src_p = _i = 0, _len = src.length; _i < _len; src_p = ++_i) {
        c = src[src_p];
        if (!((d = this.decode_map[c]) != null)) {
          continue;
        }
        res = res.multiply(this.base_big).add(nbv(d));
        if (++consumed === this.out_block_len) {
          break;
        }
      }
      res = new Buffer(res.toByteArray());
      padlen = this.decoded_len(consumed) - res.length;
      pad = new Buffer((function() {
        var _j, _results;
        _results = [];
        for (i = _j = 0; 0 <= padlen ? _j < padlen : _j > padlen; i = 0 <= padlen ? ++_j : --_j) {
          _results.push(0);
        }
        return _results;
      })());
      return [Buffer.concat([pad, res]), src.slice(src_p + 1)];
    };

    Encoding.prototype.decoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.out_block_len) {
        return this.in_block_len;
      } else {
        nblocks = ~~(n / this.out_block_len);
        out = nblocks * this.in_block_len;
        if ((rem = n % this.out_block_len) > 0) {
          out += Math.floor(rem * this.log58 / 8);
        }
        return out;
      }
    };

    return Encoding;

  })();

  exports.std_alphabet = std_alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

  exports.std_encoding = std_encoding = new Encoding(std_alphabet, 19);

}).call(this);
